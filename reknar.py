"""
Reknar: A page ranker
Reknar uses the URL graph generated by Redips
"""

import cPickle

def load(pickle):
    """
    file(pickle) -> Reknar
    Return the Reknar object stored in the pickle
    """
    with open(pickle, 'rb') as pickle_file:
        reknar = cPickle.load(pickle_file)
        reknar.pickle = pickle
    return reknar

class Reknar:
    def __init__(self, graph, pickle='reknar.pickle'):
        self.graph = graph
        self.damping_factor = 0.8
        self.numloops = 10
        self.ranks = {}
        self.pickle = pickle
        self.incoming_graph = {}
        for node in self.graph:
            for page in self.graph[node]:
                if page in self.incoming_graph:
                    self.incoming_graph[page].append(node)
                else:
                    self.incoming_graph[page] = [node]

        self.npages = len(self.graph)

        for page in self.graph:
            self.ranks[page] = 1.0 / self.npages

    def compute_ranks(self):
        """
        None -> None
        Compute the ranks of the webpages using the graph from a Redips crawler
        """

        for i in range(self.numloops):
            newranks = {}
            for page in self.graph:
                newrank = (1 - self.damping_factor) / self.npages
                for node in self.incoming_graph[page]:
                    if node in self.ranks:
                        newrank = newrank + self.damping_factor * (self.ranks[node] / len(self.graph[node]))
                newranks[page] = newrank
            self.ranks = newranks

    def get_ranks(self):
        """
        None -> None
        Return the ranks dictionary of the Reknar object
        """
        return self.ranks

    def save(self):
        """
        None -> None
        Save the state of the Reknar in a pickle
        """
        with open(self.pickle, 'wb') as pickle:
            cPickle.dump(self, pickle)
        
    def merge_graph(self, graph):
        """
        Redips.graph -> None
        Merge Reknar's graph with the input graph
        """

        # Add pages to the graph
        for page in graph:
            if page not in self.graph:
                self.graph[page] = graph[page]
            else:
                self.graph[page].extend(graph[page])

        # Add pages to the incoming_graph
        for node in graph:
            for page in graph[node]:
                if page not in self.incoming_graph:
                    self.incoming_graph[page] = [node]
                else:
                    self.incoming_graph[page].append(node)

        # Update npages
        self.npages = len(self.graph)

        # Update ranks
        for page in graph:
            if page not in self.ranks:
                self.ranks[page] = 1.0 / self.npages

    def get_ranks(self):
        """
        None -> dict(ranks)
        Return Reknar's ranks dictionary
        """
        return self.ranks
        
        
